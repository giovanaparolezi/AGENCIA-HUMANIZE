
-- ========================================
-- 1. Nichos
-- ========================================
CREATE TABLE nichos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nome TEXT NOT NULL UNIQUE
);

-- ========================================
-- 2. Serviços/Produtos
-- ========================================
CREATE TABLE servicos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nome TEXT NOT NULL UNIQUE,
    preco NUMERIC(10,2) DEFAULT 0
);

-- ========================================
-- 3. Clientes
-- ========================================
CREATE TABLE clientes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nome TEXT NOT NULL,
    email TEXT UNIQUE NOT NULL,
    empresa TEXT,
    celular TEXT,
    nicho_id UUID REFERENCES nichos(id) ON DELETE SET NULL,
    criado_em TIMESTAMP DEFAULT NOW(),
    auth_id UUID REFERENCES auth.users(id) ON DELETE CASCADE
);

-- ========================================
-- 4. Pedidos
-- ========================================
CREATE TABLE pedidos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    cliente_id UUID REFERENCES clientes(id) ON DELETE CASCADE,
    status TEXT DEFAULT 'pendente', -- pendente, em andamento, concluído
    criado_em TIMESTAMP DEFAULT NOW()
);

-- ========================================
-- 5. Pedido_Produtos (para múltiplos produtos por pedido)
-- ========================================
CREATE TABLE pedido_produtos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pedido_id UUID REFERENCES pedidos(id) ON DELETE CASCADE,
    servico_id UUID REFERENCES servicos(id),
    quantidade INT DEFAULT 1
);

-- ========================================
-- 6. Habilitar RLS (opcional, se usar auth)
-- ========================================
ALTER TABLE clientes ENABLE ROW LEVEL SECURITY;
ALTER TABLE pedidos ENABLE ROW LEVEL SECURITY;
ALTER TABLE pedido_produtos ENABLE ROW LEVEL SECURITY;
INSERT INTO nichos (nome) VALUES
('Marketing Digital'),
('Design Gráfico'),
('Desenvolvimento Web'),
('Fotografia'),
('Consultoria Empresarial');
-- Clientes: qualquer usuário pode ver os clientes
create policy "Permitir leitura de clientes"
on clientes
for select
using (true);

-- Pedidos: qualquer usuário pode ver pedidos
create policy "Permitir leitura de pedidos"
on pedidos
for select
using (true);

-- Pedido_Produtos: qualquer usuário pode ver
create policy "Permitir leitura de pedido_produtos"
on pedido_produtos
for select
using (true);

create policy "Permitir inserção de pedidos"
on pedidos
for insert
with check (true);

create policy "Permitir inserção de pedido_produtos"
on pedido_produtos
for insert
with check (true);
-- CLIENTE: só vê os próprios pedidos
alter table pedidos enable row level security;
create policy "Cliente vê apenas seus pedidos"
on pedidos
for select
using (auth.uid() = cliente_id);

-- CLIENTE: só pode inserir pedidos vinculados a si mesmo
create policy "Cliente cria pedidos"
on pedidos
for insert
with check (auth.uid() = cliente_id);

-- ADMIN: se quiser que veja todos, você pode criar política opcional
-- Substitua o UUID do admin pelo correto
-- create policy "Admin vê todos os pedidos"
-- on pedidos for select
-- using (auth.uid() = 'UUID_DO_ADMIN');
[10:07, 02/10/2025] Giovana: create policy "Cliente pode se cadastrar"
on clientes
for insert
with check (auth.uid() = auth_id);
alter table clientes enable row level security;

 ALTER TABLE clientes ENABLE ROW LEVEL SECURITY;
-- Permitir leitura de clientes (opcional, admin ou público)



-- Permitir atualização do cliente
CREATE POLICY "Cliente atualiza dados"
ON clientes
FOR UPDATE
USING (auth.uid() = auth_id)
WITH CHECK (auth.uid() = auth_id);

 -- Permitir que usuários logados leiam seus próprios dados
CREATE POLICY "Clientes podem ler seus próprios dados"
ON clientes
FOR SELECT
USING (auth_id = auth.uid());

-- Permitir que usuários logados insiram seus dados
CREATE POLICY "Clientes podem inserir seu próprio registro"
ON clientes
FOR INSERT
WITH CHECK (auth_id = auth.uid());

-- TABELAS
CREATE TABLE IF NOT EXISTS nichos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome TEXT NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS servicos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome TEXT NOT NULL UNIQUE,
  preco NUMERIC(10,2) DEFAULT 0
);

CREATE TABLE IF NOT EXISTS clientes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome TEXT NOT NULL,
  email TEXT UNIQUE NOT NULL,
  empresa TEXT,
  celular TEXT,
  nicho_id UUID REFERENCES nichos(id) ON DELETE SET NULL,
  auth_id UUID UNIQUE NOT NULL,
  criado_em TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS pedidos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cliente_id UUID REFERENCES clientes(id) ON DELETE CASCADE,
  status TEXT DEFAULT 'pendente',
  criado_em TIMESTAMP DEFAULT now()
);

CREATE TABLE IF NOT EXISTS pedido_produtos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  pedido_id UUID REFERENCES pedidos(id) ON DELETE CASCADE,
  servico_id UUID REFERENCES servicos(id),
  quantidade INT DEFAULT 1
);

-- DADOS INICIAIS
INSERT INTO nichos (nome) VALUES
  ('Marketing Digital'),
  ('Design Gráfico'),
  ('Desenvolvimento Web'),
  ('Fotografia'),
  ('Consultoria Empresarial')
ON CONFLICT DO NOTHING;

-- ATIVAR SEGURANÇA (RLS)
ALTER TABLE clientes ENABLE ROW LEVEL SECURITY;
ALTER TABLE pedidos ENABLE ROW LEVEL SECURITY;
ALTER TABLE pedido_produtos ENABLE ROW LEVEL SECURITY;

-- POLÍTICAS: CLIENTES
CREATE POLICY "Cliente pode ver seus dados"
ON clientes FOR SELECT
USING (auth_id = auth.uid());



CREATE POLICY "Cliente atualiza seus dados"
ON clientes FOR UPDATE
USING (auth_id = auth.uid())
WITH CHECK (auth_id = auth.uid());

-- POLÍTICAS: PEDIDOS
CREATE POLICY "Cliente vê seus pedidos"
ON pedidos FOR SELECT
USING (
  cliente_id = (SELECT id FROM clientes WHERE auth_id = auth.uid())
);


-- POLÍTICAS: PEDIDO_PRODUTOS
CREATE POLICY "Cliente vê pedido_produtos"
ON pedido_produtos FOR SELECT
USING (
  pedido_id IN (
    SELECT p.id
    FROM pedidos p
    JOIN clientes c ON p.cliente_id = c.id
    WHERE c.auth_id = auth.uid()
  )
);

CREATE POLICY "Cliente insere pedido_produtos"
ON pedido_produtos FOR INSERT
WITH CHECK (
  pedido_id IN (
    SELECT p.id
    FROM pedidos p
    JOIN clientes c ON p.cliente_id = c.id
    WHERE c.auth_id = auth.uid()
  )
);
-- Para que o cliente possa inserir seu próprio registro
create policy "Clientes podem se cadastrar"
on clientes
for insert
with check (auth.uid() = auth_id);

CREATE TABLE IF NOT EXISTS clientes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nome TEXT NOT NULL,
  email TEXT UNIQUE NOT NULL,
  empresa TEXT,
  celular TEXT,
  nicho_id UUID REFERENCES nichos(id) ON DELETE SET NULL,
  auth_id UUID UNIQUE NOT NULL,
  criado_em TIMESTAMP DEFAULT now()
);
CREATE POLICY "Permitir inserção sem auth"
ON clientes
FOR INSERT
WITH CHECK (true);


-- Políticas para ADMIN poder gerenciar tudo
CREATE POLICY "Admin pode gerenciar todos os pedidos" ON pedidos
FOR ALL USING (true);

CREATE POLICY "Admin pode gerenciar todos os clientes" ON clientes  
FOR ALL USING (true);

CREATE POLICY "Admin pode gerenciar pedido_produtos" ON pedido_produtos
FOR ALL USING (true);

-- Manter as políticas existentes para clientes
CREATE POLICY "Clientes podem ver seus próprios pedidos" ON pedidos
FOR SELECT USING (
  cliente_id IN (SELECT id FROM clientes WHERE auth_id = auth.uid())
);

CREATE POLICY "Clientes podem inserir seus próprios pedidos" ON pedidos  
FOR INSERT WITH CHECK (
  cliente_id IN (SELECT id FROM clientes WHERE auth_id = auth.uid())
);

-- Criar tabela de notificações
CREATE TABLE notificacoes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cliente_id UUID REFERENCES clientes(id) ON DELETE CASCADE,
  pedido_id UUID REFERENCES pedidos(id) ON DELETE CASCADE,
  tipo TEXT NOT NULL,
  mensagem TEXT NOT NULL,
  lida BOOLEAN DEFAULT FALSE,
  criado_em TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Habilitar RLS na tabela
ALTER TABLE notificacoes ENABLE ROW LEVEL SECURITY;

-- Políticas para notificações
CREATE POLICY "Admin pode gerenciar notificacoes" ON notificacoes
FOR ALL USING (true);

CREATE POLICY "Clientes veem suas notificacoes" ON notificacoes  
FOR SELECT USING (cliente_id IN (SELECT id FROM clientes WHERE auth_id = auth.uid()));

-- Para garantir que o admin tenha acesso total
CREATE POLICY "Admin acesso total pedidos" ON pedidos
FOR ALL USING (true);

CREATE POLICY "Admin acesso total clientes" ON clientes  
FOR ALL USING (true);

CREATE POLICY "Admin acesso total pedido_produtos" ON pedido_produtos
FOR ALL USING (true);

-- Tabela para agendamentos de reunião
CREATE TABLE agendamentos_reuniao (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nome TEXT NOT NULL,
    email TEXT NOT NULL,
    assunto TEXT NOT NULL,
    data DATE NOT NULL,
    horario TIME NOT NULL,
    mensagem TEXT,
    cliente_id UUID REFERENCES clientes(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'pendente',
    criado_em TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Habilitar RLS
ALTER TABLE agendamentos_reuniao ENABLE ROW LEVEL SECURITY;

-- Políticas para agendamentos
CREATE POLICY "Admin pode gerenciar agendamentos" ON agendamentos_reuniao
FOR ALL USING (true);

CREATE POLICY "Clientes veem seus agendamentos" ON agendamentos_reuniao  
FOR SELECT USING (cliente_id IN (SELECT id FROM clientes WHERE auth_id = auth.uid()));

CREATE POLICY "Permitir inserção de agendamentos" ON agendamentos_reuniao
FOR INSERT WITH CHECK (true);

CREATE TABLE IF NOT EXISTS agendamentos_reuniao (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nome TEXT NOT NULL,
    email TEXT NOT NULL,
    assunto TEXT NOT NULL,
    data DATE NOT NULL,
    horario TIME NOT NULL,
    mensagem TEXT,
    status TEXT DEFAULT 'pendente',
    criado_em TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Permitir inserções
DROP POLICY IF EXISTS "Permitir inserção de agendamentos" ON agendamentos_reuniao;
CREATE POLICY "Permitir inserção de agendamentos" ON agendamentos_reuniao
FOR INSERT WITH CHECK (true);

-- Permitir leitura
CREATE POLICY "Permitir leitura de agendamentos" ON agendamentos_reuniao
FOR SELECT USING (true);

CREATE TABLE password_reset_tokens (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  cliente_id UUID REFERENCES clientes(id) ON DELETE CASCADE,
  token TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Criar índice para melhor performance
CREATE INDEX idx_password_reset_tokens_token ON password_reset_tokens(token);
CREATE INDEX idx_password_reset_tokens_expires_at ON password_reset_tokens(expires_at);

-- Verificar se a tabela existe
CREATE TABLE IF NOT EXISTS password_reset_tokens (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  cliente_id UUID NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
  token TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  used BOOLEAN DEFAULT FALSE
);

-- Criar índices
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_expires_at ON password_reset_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_cliente_id ON password_reset_tokens(cliente_id);

-- Criar a tabela de tokens se não existir
CREATE TABLE IF NOT EXISTS password_reset_tokens (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  cliente_id UUID NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
  token TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  used BOOLEAN DEFAULT FALSE
);

-- Criar índices
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_expires_at ON password_reset_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_password_reset_tokens_cliente_id ON password_reset_tokens(cliente_id);


-- Verificar e criar tabela de tokens
CREATE TABLE IF NOT EXISTS password_reset_tokens (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  cliente_id UUID NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
  token TEXT NOT NULL UNIQUE,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  used BOOLEAN DEFAULT FALSE
);

-- Criar índices para performance
CREATE INDEX IF NOT EXISTS idx_tokens_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_tokens_expires ON password_reset_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_tokens_cliente ON password_reset_tokens(cliente_id);

-- Configurar políticas RLS (se necessário)
ALTER TABLE password_reset_tokens ENABLE ROW LEVEL SECURITY;

-- Política para permitir inserção e leitura sem autenticação
DROP POLICY IF EXISTS "Permitir tudo para password_reset_tokens" ON password_reset_tokens;
CREATE POLICY "Permitir tudo para password_reset_tokens" ON password_reset_tokens
FOR ALL USING (true);

-- Criar tabela de tokens de recuperação
CREATE TABLE IF NOT EXISTS password_reset_tokens (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  cliente_id UUID REFERENCES clientes(id) ON DELETE CASCADE,
  token TEXT UNIQUE NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  used BOOLEAN DEFAULT FALSE
);

-- Criar índices para melhor performance
CREATE INDEX IF NOT EXISTS idx_tokens_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_tokens_expires ON password_reset_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_tokens_cliente ON password_reset_tokens(cliente_id);

-- Configurar políticas (se usar RLS)
ALTER TABLE password_reset_tokens ENABLE ROW LEVEL SECURITY;

-- Política para permitir acesso sem autenticação
DROP POLICY IF EXISTS "allow_all_password_reset" ON password_reset_tokens;
CREATE POLICY "allow_all_password_reset" ON password_reset_tokens
FOR ALL USING (true);
ALTER TABLE clientes ADD COLUMN senha TEXT;-- Adicionar coluna de senha se não existir
ALTER TABLE clientes ADD COLUMN IF NOT EXISTS senha TEXT;
ALTER TABLE clientes ADD COLUMN IF NOT EXISTS atualizado_em TIMESTAMP DEFAULT NOW();

-- Permitir atualizações (desative RLS temporariamente se necessário)
ALTER TABLE clientes DISABLE ROW LEVEL SECURITY;
CREATE OR REPLACE FUNCTION resetar_senha(token_text TEXT, nova_senha TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  token_record password_reset_tokens%ROWTYPE;
  cliente_id UUID;
BEGIN
  -- Buscar o token
  SELECT * INTO token_record
  FROM password_reset_tokens
  WHERE token = token_text AND used = FALSE AND expires_at > NOW();

  IF token_record IS NULL THEN
    RETURN FALSE;
  END IF;

  -- Marcar o token como usado
  UPDATE password_reset_tokens SET used = TRUE WHERE id = token_record.id;

  -- Atualizar a senha do cliente
  UPDATE clientes SET senha = nova_senha WHERE id = token_record.cliente_id;

  RETURN TRUE;
END;
$$;

-- Remover políticas existentes na tabela clientes
DROP POLICY IF EXISTS "Cliente pode ver seus dados" ON clientes;
DROP POLICY IF EXISTS "Clientes podem ler seus próprios dados" ON clientes;
DROP POLICY IF EXISTS "Cliente atualiza seus dados" ON clientes;
DROP POLICY IF EXISTS "Clientes podem inserir seu próprio registro" ON clientes;
DROP POLICY IF EXISTS "Clientes podem se cadastrar" ON clientes;
DROP POLICY IF EXISTS "Permitir inserção sem auth" ON clientes;
DROP POLICY IF EXISTS "Admin pode gerenciar todos os clientes" ON clientes;
DROP POLICY IF EXISTS "Cliente pode se cadastrar" ON clientes;
DROP POLICY IF EXISTS "Cliente atualiza dados" ON clientes;

-- Criar novas políticas simplificadas para clientes
CREATE POLICY "Clientes leem seus dados" ON clientes
FOR SELECT USING (auth_id = auth.uid());

CREATE POLICY "Clientes inserem seus dados" ON clientes
FOR INSERT WITH CHECK (auth_id = auth.uid());

CREATE POLICY "Clientes atualizam seus dados" ON clientes
FOR UPDATE USING (auth_id = auth.uid());

-- Política para permitir update durante o reset de senha (sem auth)
CREATE POLICY "Permitir update para reset de senha" ON clientes
FOR UPDATE USING (true);

-- Criar a tabela se não existir (já existe, então só garantir a estrutura)
CREATE TABLE IF NOT EXISTS password_reset_tokens (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    cliente_id UUID NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
    token TEXT UNIQUE NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    used BOOLEAN DEFAULT FALSE
);

-- Criar índices
CREATE INDEX IF NOT EXISTS idx_tokens_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_tokens_expires ON password_reset_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_tokens_cliente ON password_reset_tokens(cliente_id);

-- Ativar RLS
ALTER TABLE password_reset_tokens ENABLE ROW LEVEL SECURITY;

-- Política para permitir todas as operações em password_reset_tokens (sem autenticação)
DROP POLICY IF EXISTS "allow_all_password_reset" ON password_reset_tokens;
CREATE POLICY "allow_all_password_reset" ON password_reset_tokens
FOR ALL USING (true);

-- Função para criar token de reset
CREATE OR REPLACE FUNCTION criar_token_reset(email_text TEXT)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    token_uuid TEXT;
    cliente_record RECORD;
BEGIN
    -- Buscar cliente pelo email
    SELECT * INTO cliente_record 
    FROM clientes 
    WHERE email = email_text;
    
    IF cliente_record.id IS NULL THEN
        RETURN NULL;
    END IF;
    
    -- Gerar token
    token_uuid := gen_random_uuid()::text;
    
    -- Inserir token
    INSERT INTO password_reset_tokens 
    (cliente_id, token, expires_at)
    VALUES 
    (cliente_record.id, token_uuid, NOW() + INTERVAL '1 hour');
    
    RETURN token_uuid;
END;
$$;

-- Função para resetar senha
CREATE OR REPLACE FUNCTION resetar_senha(token_text TEXT, nova_senha TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    token_record RECORD;
BEGIN
    -- Verificar token
    SELECT * INTO token_record
    FROM password_reset_tokens
    WHERE token = token_text 
    AND expires_at > NOW() 
    AND NOT used;
    
    IF token_record.id IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Atualizar senha
    UPDATE clientes 
    SET senha = nova_senha,
        atualizado_em = NOW()
    WHERE id = token_record.cliente_id;
    
    -- Marcar token como usado
    UPDATE password_reset_tokens
    SET used = TRUE
    WHERE id = token_record.id;
    
    RETURN TRUE;
END;
$$;

ALTER TABLE clientes ADD COLUMN IF NOT EXISTS atualizado_em TIMESTAMP DEFAULT NOW();

ALTER TABLE clientes ADD COLUMN IF NOT EXISTS senha TEXT;

-- Verificar e criar tabela de tokens se não existir
CREATE TABLE IF NOT EXISTS password_reset_tokens (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    cliente_id UUID NOT NULL REFERENCES clientes(id) ON DELETE CASCADE,
    token TEXT NOT NULL UNIQUE,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    used BOOLEAN DEFAULT FALSE
);

-- Criar índices para performance
CREATE INDEX IF NOT EXISTS idx_tokens_token ON password_reset_tokens(token);
CREATE INDEX IF NOT EXISTS idx_tokens_expires ON password_reset_tokens(expires_at);
CREATE INDEX IF NOT EXISTS idx_tokens_cliente ON password_reset_tokens(cliente_id);

-- Garantir que a coluna de senha existe
ALTER TABLE clientes ADD COLUMN IF NOT EXISTS senha TEXT;
ALTER TABLE clientes ADD COLUMN IF NOT EXISTS atualizado_em TIMESTAMP DEFAULT NOW();

-- Configurar políticas RLS (se necessário)
ALTER TABLE password_reset_tokens ENABLE ROW LEVEL SECURITY;

-- Política para permitir todas as operações em password_reset_tokens
DROP POLICY IF EXISTS "allow_all_password_reset" ON password_reset_tokens;
CREATE POLICY "allow_all_password_reset" ON password_reset_tokens
FOR ALL USING (true);

-- 1. Garantir que a tabela nichos tem RLS desativado ou política de leitura pública
ALTER TABLE nichos ENABLE ROW LEVEL SECURITY;

-- Política para permitir leitura pública dos nichos
DROP POLICY IF EXISTS "Permitir leitura pública de nichos" ON nichos;
CREATE POLICY "Permitir leitura pública de nichos" ON nichos
FOR SELECT USING (true);

-- 2. Corrigir políticas da tabela clientes
DROP POLICY IF EXISTS "Clientes podem inserir seus dados" ON clientes;
CREATE POLICY "Clientes podem inserir seus dados" ON clientes
FOR INSERT WITH CHECK (auth.uid() = auth_id);

-- 3. Garantir que novos usuários possam se cadastrar
DROP POLICY IF EXISTS "Permitir inserção durante cadastro" ON clientes;
CREATE POLICY "Permitir inserção durante cadastro" ON clientes
FOR INSERT WITH CHECK (true);

-- 4. Verificar se os nichos existem na tabela
INSERT INTO nichos (nome) VALUES
('Marketing Digital'),
('Design Gráfico'),
('Desenvolvimento Web'),
('Fotografia'),
('Consultoria Empresarial')
ON CONFLICT (nome) DO NOTHING;

create or replace function criar_token_reset(email_text text)
returns text
language plpgsql
as $$
declare
  cliente_id uuid;
  token text := encode(gen_random_bytes(16), 'hex');
begin
  select id into cliente_id from clientes where email = email_text;

  if cliente_id is null then
    return null;
  end if;

  insert into tokens_reset_senha (token, id_cliente, expira_em)
  values (token, cliente_id, now() + interval '1 hour');

  perform
    net.http_post(
      url := 'https://aoyycbedxetmnavmhesf.supabase.co/functions/v1/send-reset-email',
      headers := jsonb_build_object('Content-Type', 'application/json'),
      body := jsonb_build_object(
        'email', email_text,
        'token', token
      )
    );

  return token;
end;
$$;
create or replace function criar_token_reset(email_text text)
returns text
language plpgsql
security definer
as $$
declare
  cliente_id uuid;
  token text := encode(gen_random_bytes(16), 'hex');
begin
  select id into cliente_id from clientes where email = email_text;

  if cliente_id is null then
    return null;
  end if;

  insert into password_reset_tokens (token, cliente_id, expires_at)
  values (token, cliente_id, now() + interval '1 hour');

  return token;
end;
$$;
create or replace function resetar_senha(token_text text, nova_senha text)
returns boolean
language plpgsql
security definer
as $$
declare
  token_record record;
begin
  select * into token_record
  from password_reset_tokens
  where token = token_text
    and expires_at > now()
    and used = false;

  if token_record is null then
    return false;
  end if;

  update clientes
  set senha = nova_senha,
      atualizado_em = now()
  where id = token_record.cliente_id;

  update password_reset_tokens
  set used = true
  where id = token_record.id;

  return true;
end;
$$;
CREATE OR REPLACE FUNCTION criar_token_reset(email_text TEXT)
RETURNS TEXT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  cliente_id UUID;
  token TEXT := encode(gen_random_bytes(16), 'hex');
BEGIN
  SELECT id INTO cliente_id 
  FROM clientes 
  WHERE email = email_text;

  IF cliente_id IS NULL THEN
    RETURN NULL;
  END IF;

  INSERT INTO password_reset_tokens (token, cliente_id, expires_at)
  VALUES (token, cliente_id, NOW() + INTERVAL '1 hour');

  RETURN token;
END;
$$;
CREATE OR REPLACE FUNCTION resetar_senha(token_text TEXT, nova_senha TEXT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  token_record RECORD;
BEGIN
  -- Buscar token válido
  SELECT * INTO token_record
  FROM password_reset_tokens
  WHERE token = token_text
    AND expires_at > NOW()
    AND used = FALSE;

  IF token_record IS NULL THEN
    RETURN FALSE;
  END IF;

  -- Atualizar a senha
  UPDATE clientes
  SET senha = nova_senha,
      atualizado_em = NOW()
  WHERE id = token_record.cliente_id;

  -- Marcar token como usado
  UPDATE password_reset_tokens
  SET used = TRUE
  WHERE id = token_record.id;

  RETURN TRUE;
END;
$$;
